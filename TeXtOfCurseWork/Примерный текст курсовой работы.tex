\documentclass[12pt, oneside]{article} 

\usepackage{polyglossia}

\setdefaultlanguage[spelling=modern]{russian}
\setotherlanguage{english} 
\defaultfontfeatures{Scale=MatchLowercase,Ligatures=TeX}  %% устанавливает поведение шрифтов по умолчанию  
\newfontfamily\cyrillicfont{Linux Libertine} 
\setromanfont[Mapping=tex-text]{Linux Libertine}
\setsansfont[Mapping=tex-text]{Linux Biolinum}
\setmonofont{DejaVu Sans Mono}

\begin{document}
\section{Физический движок.}
\subsection{Определение.}

Физический движок $ (Physics Engine) $ — программа (или подпрограмма), моделирующая тот или иной физический процесс\cite{Korn}.

Рассмотрим понятие физический движок на классическом примере движка, моделирующего физику твердых тел на основе импульсов (впрочем, большая часть сказанного относится и к другим методам). Фактически, все, что требуется от такого движка — уметь выполнять запросы вида «добавить тело», «симулировать шаг времени», «взять позицию/ориентацию данного тела» и другие. Рассмотрим подробнее основную его функцию «симулировать шаг времени», выполняемую каждый кадр в реалтайм приложении, например, в игре. В каждом кадре мы прежде всего обязательно должны найти все потенциально взаимодействующие пары тел. Этот шаг называется Broadphase. Чтобы сузить количество пар для проверок, применяются алгоритмы:

$Sweep And Prune$ — один из самых легко реализуемых, но в то же время достаточно эффективных алгоритмов.

$QuadTree / Octree$ и их расширения, такие, как $loose tree$ — алгоримы по разбиению пространства ($Spacial Hashing$). Основываются на сужении круга поиска контактирующих тел в рамках суженной области пространства, например, нет смысла пытаться искать контакт чайника, стоящего на столе с автомобилем, стоящим под окном.

Множество алгоритмов, основывающихся на так называемом эффекте $Temporal coherence$, который можно толковать как «временная когерентность». Суть состоит в том, что тела от кадра к кадру обычно сдвигаются на малое расстояние, и тела, которые на данной итерации находятся далеко друг от друга, на следующей наверняка будут находиться незначительно ближе.

Далее, найдя пары потенциально пересекающихся тел, вступает в силу $Narrowphase$ — стадия, на которой движок должен находить точные данные о контакте тел — находить точки контакта, нормали и глубины проникновения. 

Следующая стадия — разрешение найденных контактов и других типов связей, которым занимается $Solver$

Завершающая стадия — интегрирование позиции. То есть, собственно, смещение всех тел сцены. Стадия не очень сложная, выбор алгоритмов её реализации невелик, но зато они отлично работают — интеграторы по Эйлеру, Ньютону и Рунге-Кутта.

Также сквозь все стадии «просачиваются» такие функции, как коллбэки ($callbacks$) на события, например, вызов некоторой функции, при каждом касания чайника со столом. И фризинг ($freezing$) или, как его ещё называют, $sleeping$ тел — алгоритмы, «выкидывающие» из просчета слишком долго находящиеся в покое или, например, невидимые игроку тела.

\subsection{Функционльные возможности}
\begin{enumerate} 
\item Просчитывание столкновения (англ. $collision shapes$) таких фигур: сфера, параллелепипед, цилиндр, конус, выпуклый корпус и сетка треугольников (англ. $triangle mesh$);
\item Реализация алгоритма расчёта столкновений Гилберта-Джонсона-Кёрти ($GJK$) и $EPA$ (англ. $Expanded Polytope Algorithm$);
\item Просчёт пересечения координат в AABB-деревьях (англ. $Swept collision test$);
\item Раздельный (англ. $discrete$) и непрерывный расчёт столкновений ($CCD$);
\item Поддержка мягких тел (англ. $soft body$) и, как развитие технологии, тканей;
\item Поддержка $CUDA$ и $OpenCL$;
\item Гидродинамика сглаженных частиц;
\item Ограничители (англ. $constraints$);
\item Многопоточность;
\item Кроссплатформенность;
\end{enumerate}

\subsection{Что запланированно реализовать.}
\begin{enumerate} 
\item Просчитывание столкновения фигур: сфера, параллелепипед, цилиндр, конус, сетка треугольников;
\item Реализация алгоритма расчёта столкновений;
\item Многопоточность;
\item Кроссплатформенность;
\end{enumerate}

\end{document}


